Interrupt Vectors
    00000 940C 004B JMP	__text_start|__start
    00016 940C 0516 JMP	_usart_read
    00024 940C 038C JMP	_int2

Program Code (text area)
__text_start|__start:
    0004B E5CF      LDI	R28,0x5F
    0004C E0D4      LDI	R29,4
    0004D BFCD      OUT	0x3D,R28
    0004E BFDE      OUT	0x3E,R29
    0004F 51CE      SUBI	R28,0x1E
    00050 40D0      SBCI	R29,0
    00051 EA0A      LDI	R16,0xAA
    00052 8308      ST	Y,R16
    00053 2400      CLR	R0
    00054 EAE2      LDI	R30,0xA2
    00055 E0F0      LDI	R31,0
    00056 E010      LDI	R17,0
    00057 3BEB      CPI	R30,0xBB
    00058 07F1      CPC	R31,R17
    00059 F011      BEQ	0x005C
    0005A 9201      ST	Z+,R0
    0005B CFFB      RJMP	0x0057
    0005C 8300      ST	Z,R16
    0005D E5E4      LDI	R30,0x54
    0005E E0F0      LDI	R31,0
    0005F E6A0      LDI	R26,0x60
    00060 E0B0      LDI	R27,0
    00061 E010      LDI	R17,0
    00062 E000      LDI	R16,0
    00063 BF0B      OUT	0x3B,R16
    00064 39E6      CPI	R30,0x96
    00065 07F1      CPC	R31,R17
    00066 F021      BEQ	0x006B
    00067 95C8      LPM
    00068 9631      ADIW	R30,1
    00069 920D      ST	X+,R0
    0006A CFF9      RJMP	0x0064
    0006B 940E 007C CALL	_main
_exit:
    0006D CFFF      RJMP	_exit
FILE: C:\Users\Administrator\Desktop\交通灯\main.c
(0001) #include<iom16v.h>
(0002) #include<macros.h>
(0003) #include"MAX7219.h"
(0004) #include"74LS139.h"
(0005) #include"button.h"
(0006) #include"delay.h"
(0007) #include"ds1307.h"
(0008) #include"twi.h"
(0009) #include"usart.h"
(0010) 
(0011) uchar Number_H,Number_L,count=0;
(0012) 
(0013) void io_init()
(0014) {
(0015)   DDRA=0xFF;
_io_init:
    0006E EF8F      LDI	R24,0xFF
    0006F BB8A      OUT	0x1A,R24
(0016)   PORTA=0x00;
    00070 2422      CLR	R2
    00071 BA2B      OUT	0x1B,R2
(0017)   DDRB=0xff;
    00072 BB87      OUT	0x17,R24
(0018)   PORTB=0xff;
    00073 BB88      OUT	0x18,R24
(0019)   DDRC=0xe7;
    00074 EE87      LDI	R24,0xE7
    00075 BB84      OUT	0x14,R24
(0020)   PORTC=0x00;
    00076 BA25      OUT	0x15,R2
(0021)   DDRD=0x02;
    00077 E082      LDI	R24,2
    00078 BB81      OUT	0x11,R24
(0022)   PORTD=0x04;
    00079 E084      LDI	R24,4
    0007A BB82      OUT	0x12,R24
    0007B 9508      RET
_main:
    0007C 9721      SBIW	R28,1
(0023) }
(0024) 
(0025) void main()
(0026) {
(0027)   io_init();
    0007D DFF0      RCALL	_io_init
(0028)   TWI_init();
    0007E 940E 03F4 CALL	_TWI_init
(0029)   TWI_Write(WD_DS1307_ADDR,0X10,7);           //设置ds1307输出方波
    00080 E087      LDI	R24,7
    00081 8388      ST	Y,R24
    00082 E120      LDI	R18,0x10
    00083 ED00      LDI	R16,0xD0
    00084 940E 03F9 CALL	_TWI_Write
(0030)   Init_MAX7219();
    00086 940E 033A CALL	_Init_MAX7219
(0031)   int2_init();
    00088 940E 0389 CALL	_int2_init
(0032)   usart_init();
    0008A 940E 050B CALL	_usart_init
(0033)   redTime = Read_EEprom(0);      //读取红绿黄灯的时间
    0008C 2700      CLR	R16
    0008D 2711      CLR	R17
    0008E 940E 0641 CALL	_Read_EEprom
    00090 9300 00A4 STS	redTime,R16
(0034)   greenTime = Read_EEprom(1);
    00092 E001      LDI	R16,1
    00093 E010      LDI	R17,0
    00094 940E 0641 CALL	_Read_EEprom
    00096 9300 00A5 STS	greenTime,R16
(0035)   yellowTime = Read_EEprom(2);
    00098 E002      LDI	R16,2
    00099 E010      LDI	R17,0
    0009A 940E 0641 CALL	_Read_EEprom
    0009C 0158      MOVW	R10,R16
    0009D 92A0 00A6 STS	yellowTime,R10
(0036)   SREG|=BIT(7);
    0009F 9478      BSET	7
    000A0 C264      RJMP	0x0305
(0037) 
(0038)   while(1)
(0039)   {
(0040)     if(daytimeFlag)
    000A1 9020 006B LDS	R2,daytimeFlag
    000A3 2022      TST	R2
    000A4 F409      BNE	0x00A6
    000A5 C1FF      RJMP	0x02A5
(0041) 	{
(0042) 	  LS139_G_L;
    000A6 98DC      CBI	0x1B,4
(0043) 	  Write_Max7219(0x0c, 0x01);       //掉电模式：0，普通模式：1
    000A7 E021      LDI	R18,1
    000A8 E030      LDI	R19,0
    000A9 E00C      LDI	R16,0xC
    000AA E010      LDI	R17,0
    000AB 940E 032D CALL	_Write_Max7219
(0044) 	  GICR |= (1<<INT2);			//打开外部中断2
    000AD B78B      IN	R24,0x3B
    000AE 6280      ORI	R24,0x20
    000AF BF8B      OUT	0x3B,R24
    000B0 C047      RJMP	0x00F8
(0045) 	  while(secCount<=greenTime)
(0046) 	  {
(0047) 	    if(urgencyFlag | nightFlag)break;
    000B1 9020 006C LDS	R2,nightFlag
    000B3 9030 006A LDS	R3,urgencyFlag
    000B5 2832      OR	R3,R2
    000B6 F009      BEQ	0x00B8
    000B7 C0A6      RJMP	0x015E
(0048) 	    Write_Max7219(1,decode_H(greenTime-secCount));
    000B8 9020 0068 LDS	R2,secCount
    000BA 2433      CLR	R3
    000BB 9100 00A5 LDS	R16,greenTime
    000BD 2711      CLR	R17
    000BE 1902      SUB	R16,R2
    000BF 0913      SBC	R17,R3
    000C0 D247      RCALL	_decode_H
    000C1 0158      MOVW	R10,R16
    000C2 0195      MOVW	R18,R10
    000C3 E001      LDI	R16,1
    000C4 E010      LDI	R17,0
    000C5 940E 032D CALL	_Write_Max7219
(0049)         Write_Max7219(2,decode_L(greenTime-secCount));
    000C7 9020 0068 LDS	R2,secCount
    000C9 2433      CLR	R3
    000CA 9100 00A5 LDS	R16,greenTime
    000CC 2711      CLR	R17
    000CD 1902      SUB	R16,R2
    000CE 0913      SBC	R17,R3
    000CF D242      RCALL	_decode_L
    000D0 0158      MOVW	R10,R16
    000D1 0195      MOVW	R18,R10
    000D2 E002      LDI	R16,2
    000D3 E010      LDI	R17,0
    000D4 940E 032D CALL	_Write_Max7219
(0050) 		Write_Max7219(3,decode_H(greenTime-secCount));
    000D6 9020 0068 LDS	R2,secCount
    000D8 2433      CLR	R3
    000D9 9100 00A5 LDS	R16,greenTime
    000DB 2711      CLR	R17
    000DC 1902      SUB	R16,R2
    000DD 0913      SBC	R17,R3
    000DE D229      RCALL	_decode_H
    000DF 0158      MOVW	R10,R16
    000E0 0195      MOVW	R18,R10
    000E1 E003      LDI	R16,3
    000E2 E010      LDI	R17,0
    000E3 940E 032D CALL	_Write_Max7219
(0051)         Write_Max7219(4,decode_L(greenTime-secCount));
    000E5 9020 0068 LDS	R2,secCount
    000E7 2433      CLR	R3
    000E8 9100 00A5 LDS	R16,greenTime
    000EA 2711      CLR	R17
    000EB 1902      SUB	R16,R2
    000EC 0913      SBC	R17,R3
    000ED D224      RCALL	_decode_L
    000EE 0158      MOVW	R10,R16
    000EF 0195      MOVW	R18,R10
    000F0 E004      LDI	R16,4
    000F1 E010      LDI	R17,0
    000F2 940E 032D CALL	_Write_Max7219
(0052) 		main_green();
    000F4 940E 034C CALL	_main_green
(0053) 		second_red();
    000F6 940E 0355 CALL	_second_red
    000F8 9020 00A5 LDS	R2,greenTime
    000FA 2433      CLR	R3
    000FB 9040 0068 LDS	R4,secCount
    000FD 2455      CLR	R5
    000FE 1424      CP	R2,R4
    000FF 0435      CPC	R3,R5
    00100 F00C      BLT	0x0102
    00101 CFAF      RJMP	0x00B1
    00102 C05B      RJMP	0x015E
(0054) 	  }
(0055) 	  while(secCount>greenTime&&secCount<=(greenTime+yellowTime))
(0056) 	  {
(0057) 	    if(urgencyFlag | nightFlag)break;
    00103 9020 006C LDS	R2,nightFlag
    00105 9030 006A LDS	R3,urgencyFlag
    00107 2832      OR	R3,R2
    00108 F009      BEQ	0x010A
    00109 C0DC      RJMP	0x01E6
(0058) 	    Write_Max7219(1,decode_H(greenTime+yellowTime-secCount));
    0010A 9020 00A6 LDS	R2,yellowTime
    0010C 2433      CLR	R3
    0010D 9100 00A5 LDS	R16,greenTime
    0010F 2711      CLR	R17
    00110 0D02      ADD	R16,R2
    00111 1D13      ADC	R17,R3
    00112 9020 0068 LDS	R2,secCount
    00114 2433      CLR	R3
    00115 1902      SUB	R16,R2
    00116 0913      SBC	R17,R3
    00117 D1F0      RCALL	_decode_H
    00118 0158      MOVW	R10,R16
    00119 0195      MOVW	R18,R10
    0011A E001      LDI	R16,1
    0011B E010      LDI	R17,0
    0011C 940E 032D CALL	_Write_Max7219
(0059)         Write_Max7219(2,decode_L(greenTime+yellowTime-secCount));
    0011E 9020 00A6 LDS	R2,yellowTime
    00120 2433      CLR	R3
    00121 9100 00A5 LDS	R16,greenTime
    00123 2711      CLR	R17
    00124 0D02      ADD	R16,R2
    00125 1D13      ADC	R17,R3
    00126 9020 0068 LDS	R2,secCount
    00128 2433      CLR	R3
    00129 1902      SUB	R16,R2
    0012A 0913      SBC	R17,R3
    0012B D1E6      RCALL	_decode_L
    0012C 0158      MOVW	R10,R16
    0012D 0195      MOVW	R18,R10
    0012E E002      LDI	R16,2
    0012F E010      LDI	R17,0
    00130 940E 032D CALL	_Write_Max7219
(0060) 		Write_Max7219(3,decode_H(greenTime+yellowTime-secCount));
    00132 9020 00A6 LDS	R2,yellowTime
    00134 2433      CLR	R3
    00135 9100 00A5 LDS	R16,greenTime
    00137 2711      CLR	R17
    00138 0D02      ADD	R16,R2
    00139 1D13      ADC	R17,R3
    0013A 9020 0068 LDS	R2,secCount
    0013C 2433      CLR	R3
    0013D 1902      SUB	R16,R2
    0013E 0913      SBC	R17,R3
    0013F D1C8      RCALL	_decode_H
    00140 0158      MOVW	R10,R16
    00141 0195      MOVW	R18,R10
    00142 E003      LDI	R16,3
    00143 E010      LDI	R17,0
    00144 940E 032D CALL	_Write_Max7219
(0061)         Write_Max7219(4,decode_L(greenTime+yellowTime-secCount));
    00146 9020 00A6 LDS	R2,yellowTime
    00148 2433      CLR	R3
    00149 9100 00A5 LDS	R16,greenTime
    0014B 2711      CLR	R17
    0014C 0D02      ADD	R16,R2
    0014D 1D13      ADC	R17,R3
    0014E 9020 0068 LDS	R2,secCount
    00150 2433      CLR	R3
    00151 1902      SUB	R16,R2
    00152 0913      SBC	R17,R3
    00153 D1BE      RCALL	_decode_L
    00154 0158      MOVW	R10,R16
    00155 0195      MOVW	R18,R10
    00156 E004      LDI	R16,4
    00157 E010      LDI	R17,0
    00158 940E 032D CALL	_Write_Max7219
(0062) 		main_yellow();
    0015A 940E 034F CALL	_main_yellow
(0063) 		second_yellow();
    0015C 940E 035B CALL	_second_yellow
    0015E 90A0 0068 LDS	R10,secCount
    00160 90C0 00A5 LDS	R12,greenTime
    00162 2C2C      MOV	R2,R12
    00163 2433      CLR	R3
    00164 2C4A      MOV	R4,R10
    00165 2455      CLR	R5
    00166 1424      CP	R2,R4
    00167 0435      CPC	R3,R5
    00168 F46C      BGE	0x0176
    00169 9020 00A6 LDS	R2,yellowTime
    0016B 2433      CLR	R3
    0016C 2C4C      MOV	R4,R12
    0016D 2455      CLR	R5
    0016E 0C42      ADD	R4,R2
    0016F 1C53      ADC	R5,R3
    00170 2C2A      MOV	R2,R10
    00171 2433      CLR	R3
    00172 1442      CP	R4,R2
    00173 0453      CPC	R5,R3
    00174 F00C      BLT	0x0176
    00175 CF8D      RJMP	0x0103
    00176 C06F      RJMP	0x01E6
(0064) 	  }
(0065) 	  while(secCount>(greenTime+yellowTime)&&secCount<=(greenTime+yellowTime+redTime))
(0066) 	  {
(0067) 	    if(urgencyFlag | nightFlag)break;
    00177 9020 006C LDS	R2,nightFlag
    00179 9030 006A LDS	R3,urgencyFlag
    0017B 2832      OR	R3,R2
    0017C F009      BEQ	0x017E
    0017D C107      RJMP	0x0285
(0068) 	    Write_Max7219(1,decode_H(greenTime+yellowTime+redTime-secCount));
    0017E 9020 00A6 LDS	R2,yellowTime
    00180 2433      CLR	R3
    00181 9100 00A5 LDS	R16,greenTime
    00183 2711      CLR	R17
    00184 0D02      ADD	R16,R2
    00185 1D13      ADC	R17,R3
    00186 9020 00A4 LDS	R2,redTime
    00188 2433      CLR	R3
    00189 0D02      ADD	R16,R2
    0018A 1D13      ADC	R17,R3
    0018B 9020 0068 LDS	R2,secCount
    0018D 2433      CLR	R3
    0018E 1902      SUB	R16,R2
    0018F 0913      SBC	R17,R3
    00190 D177      RCALL	_decode_H
    00191 0158      MOVW	R10,R16
    00192 0195      MOVW	R18,R10
    00193 E001      LDI	R16,1
    00194 E010      LDI	R17,0
    00195 940E 032D CALL	_Write_Max7219
(0069)         Write_Max7219(2,decode_L(greenTime+yellowTime+redTime-secCount));
    00197 9020 00A6 LDS	R2,yellowTime
    00199 2433      CLR	R3
    0019A 9100 00A5 LDS	R16,greenTime
    0019C 2711      CLR	R17
    0019D 0D02      ADD	R16,R2
    0019E 1D13      ADC	R17,R3
    0019F 9020 00A4 LDS	R2,redTime
    001A1 2433      CLR	R3
    001A2 0D02      ADD	R16,R2
    001A3 1D13      ADC	R17,R3
    001A4 9020 0068 LDS	R2,secCount
    001A6 2433      CLR	R3
    001A7 1902      SUB	R16,R2
    001A8 0913      SBC	R17,R3
    001A9 D168      RCALL	_decode_L
    001AA 0158      MOVW	R10,R16
    001AB 0195      MOVW	R18,R10
    001AC E002      LDI	R16,2
    001AD E010      LDI	R17,0
    001AE 940E 032D CALL	_Write_Max7219
(0070) 		Write_Max7219(3,decode_H(greenTime+yellowTime+redTime-secCount));
    001B0 9020 00A6 LDS	R2,yellowTime
    001B2 2433      CLR	R3
    001B3 9100 00A5 LDS	R16,greenTime
    001B5 2711      CLR	R17
    001B6 0D02      ADD	R16,R2
    001B7 1D13      ADC	R17,R3
    001B8 9020 00A4 LDS	R2,redTime
    001BA 2433      CLR	R3
    001BB 0D02      ADD	R16,R2
    001BC 1D13      ADC	R17,R3
    001BD 9020 0068 LDS	R2,secCount
    001BF 2433      CLR	R3
    001C0 1902      SUB	R16,R2
    001C1 0913      SBC	R17,R3
    001C2 D145      RCALL	_decode_H
    001C3 0158      MOVW	R10,R16
    001C4 0195      MOVW	R18,R10
    001C5 E003      LDI	R16,3
    001C6 E010      LDI	R17,0
    001C7 940E 032D CALL	_Write_Max7219
(0071)         Write_Max7219(4,decode_L(greenTime+yellowTime+redTime-secCount));
    001C9 9020 00A6 LDS	R2,yellowTime
    001CB 2433      CLR	R3
    001CC 9100 00A5 LDS	R16,greenTime
    001CE 2711      CLR	R17
    001CF 0D02      ADD	R16,R2
    001D0 1D13      ADC	R17,R3
    001D1 9020 00A4 LDS	R2,redTime
    001D3 2433      CLR	R3
    001D4 0D02      ADD	R16,R2
    001D5 1D13      ADC	R17,R3
    001D6 9020 0068 LDS	R2,secCount
    001D8 2433      CLR	R3
    001D9 1902      SUB	R16,R2
    001DA 0913      SBC	R17,R3
    001DB D136      RCALL	_decode_L
    001DC 0158      MOVW	R10,R16
    001DD 0195      MOVW	R18,R10
    001DE E004      LDI	R16,4
    001DF E010      LDI	R17,0
    001E0 940E 032D CALL	_Write_Max7219
(0072) 		main_red();
    001E2 940E 0349 CALL	_main_red
(0073) 		second_green();
    001E4 940E 0358 CALL	_second_green
    001E6 90A0 0068 LDS	R10,secCount
    001E8 9020 00A6 LDS	R2,yellowTime
    001EA 2433      CLR	R3
    001EB 90C0 00A5 LDS	R12,greenTime
    001ED 24DD      CLR	R13
    001EE 0CC2      ADD	R12,R2
    001EF 1CD3      ADC	R13,R3
    001F0 2C2A      MOV	R2,R10
    001F1 2433      CLR	R3
    001F2 14C2      CP	R12,R2
    001F3 04D3      CPC	R13,R3
    001F4 F464      BGE	0x0201
    001F5 9020 00A4 LDS	R2,redTime
    001F7 2433      CLR	R3
    001F8 0126      MOVW	R4,R12
    001F9 0C42      ADD	R4,R2
    001FA 1C53      ADC	R5,R3
    001FB 2C2A      MOV	R2,R10
    001FC 2433      CLR	R3
    001FD 1442      CP	R4,R2
    001FE 0453      CPC	R5,R3
    001FF F00C      BLT	0x0201
    00200 CF76      RJMP	0x0177
    00201 C083      RJMP	0x0285
(0074) 	  }
(0075) 	  while(secCount>(greenTime+yellowTime+redTime)&&secCount<=(greenTime+yellowTime+redTime+yellowTime))
(0076) 	  {
(0077) 	    if(urgencyFlag | nightFlag)break;
    00202 9020 006C LDS	R2,nightFlag
    00204 9030 006A LDS	R3,urgencyFlag
    00206 2832      OR	R3,R2
    00207 F009      BEQ	0x0209
    00208 C09C      RJMP	0x02A5
(0078) 	    Write_Max7219(1,decode_H(greenTime+yellowTime+redTime+yellowTime-secCount));
    00209 90A0 00A6 LDS	R10,yellowTime
    0020B 2C2A      MOV	R2,R10
    0020C 2433      CLR	R3
    0020D 9100 00A5 LDS	R16,greenTime
    0020F 2711      CLR	R17
    00210 0D02      ADD	R16,R2
    00211 1D13      ADC	R17,R3
    00212 9020 00A4 LDS	R2,redTime
    00214 2433      CLR	R3
    00215 0D02      ADD	R16,R2
    00216 1D13      ADC	R17,R3
    00217 2C2A      MOV	R2,R10
    00218 2433      CLR	R3
    00219 0D02      ADD	R16,R2
    0021A 1D13      ADC	R17,R3
    0021B 9020 0068 LDS	R2,secCount
    0021D 2433      CLR	R3
    0021E 1902      SUB	R16,R2
    0021F 0913      SBC	R17,R3
    00220 D0E7      RCALL	_decode_H
    00221 0158      MOVW	R10,R16
    00222 0195      MOVW	R18,R10
    00223 E001      LDI	R16,1
    00224 E010      LDI	R17,0
    00225 940E 032D CALL	_Write_Max7219
(0079)         Write_Max7219(2,decode_L(greenTime+yellowTime+redTime+yellowTime-secCount));
    00227 90A0 00A6 LDS	R10,yellowTime
    00229 2C2A      MOV	R2,R10
    0022A 2433      CLR	R3
    0022B 9100 00A5 LDS	R16,greenTime
    0022D 2711      CLR	R17
    0022E 0D02      ADD	R16,R2
    0022F 1D13      ADC	R17,R3
    00230 9020 00A4 LDS	R2,redTime
    00232 2433      CLR	R3
    00233 0D02      ADD	R16,R2
    00234 1D13      ADC	R17,R3
    00235 2C2A      MOV	R2,R10
    00236 2433      CLR	R3
    00237 0D02      ADD	R16,R2
    00238 1D13      ADC	R17,R3
    00239 9020 0068 LDS	R2,secCount
    0023B 2433      CLR	R3
    0023C 1902      SUB	R16,R2
    0023D 0913      SBC	R17,R3
    0023E D0D3      RCALL	_decode_L
    0023F 0158      MOVW	R10,R16
    00240 0195      MOVW	R18,R10
    00241 E002      LDI	R16,2
    00242 E010      LDI	R17,0
    00243 940E 032D CALL	_Write_Max7219
(0080) 		Write_Max7219(3,decode_H(greenTime+yellowTime+redTime+yellowTime-secCount));
    00245 90A0 00A6 LDS	R10,yellowTime
    00247 2C2A      MOV	R2,R10
    00248 2433      CLR	R3
    00249 9100 00A5 LDS	R16,greenTime
    0024B 2711      CLR	R17
    0024C 0D02      ADD	R16,R2
    0024D 1D13      ADC	R17,R3
    0024E 9020 00A4 LDS	R2,redTime
    00250 2433      CLR	R3
    00251 0D02      ADD	R16,R2
    00252 1D13      ADC	R17,R3
    00253 2C2A      MOV	R2,R10
    00254 2433      CLR	R3
    00255 0D02      ADD	R16,R2
    00256 1D13      ADC	R17,R3
    00257 9020 0068 LDS	R2,secCount
    00259 2433      CLR	R3
    0025A 1902      SUB	R16,R2
    0025B 0913      SBC	R17,R3
    0025C D0AB      RCALL	_decode_H
    0025D 0158      MOVW	R10,R16
    0025E 0195      MOVW	R18,R10
    0025F E003      LDI	R16,3
    00260 E010      LDI	R17,0
    00261 940E 032D CALL	_Write_Max7219
(0081)         Write_Max7219(4,decode_L(greenTime+yellowTime+redTime+yellowTime-secCount));
    00263 90A0 00A6 LDS	R10,yellowTime
    00265 2C2A      MOV	R2,R10
    00266 2433      CLR	R3
    00267 9100 00A5 LDS	R16,greenTime
    00269 2711      CLR	R17
    0026A 0D02      ADD	R16,R2
    0026B 1D13      ADC	R17,R3
    0026C 9020 00A4 LDS	R2,redTime
    0026E 2433      CLR	R3
    0026F 0D02      ADD	R16,R2
    00270 1D13      ADC	R17,R3
    00271 2C2A      MOV	R2,R10
    00272 2433      CLR	R3
    00273 0D02      ADD	R16,R2
    00274 1D13      ADC	R17,R3
    00275 9020 0068 LDS	R2,secCount
    00277 2433      CLR	R3
    00278 1902      SUB	R16,R2
    00279 0913      SBC	R17,R3
    0027A D097      RCALL	_decode_L
    0027B 0158      MOVW	R10,R16
    0027C 0195      MOVW	R18,R10
    0027D E004      LDI	R16,4
    0027E E010      LDI	R17,0
    0027F 940E 032D CALL	_Write_Max7219
(0082) 		main_yellow();
    00281 940E 034F CALL	_main_yellow
(0083) 		second_yellow();
    00283 940E 035B CALL	_second_yellow
    00285 90A0 0068 LDS	R10,secCount
    00287 90E0 00A6 LDS	R14,yellowTime
    00289 2C2E      MOV	R2,R14
    0028A 2433      CLR	R3
    0028B 90C0 00A5 LDS	R12,greenTime
    0028D 24DD      CLR	R13
    0028E 0CC2      ADD	R12,R2
    0028F 1CD3      ADC	R13,R3
    00290 9020 00A4 LDS	R2,redTime
    00292 2433      CLR	R3
    00293 0CC2      ADD	R12,R2
    00294 1CD3      ADC	R13,R3
    00295 2C2A      MOV	R2,R10
    00296 2433      CLR	R3
    00297 14C2      CP	R12,R2
    00298 04D3      CPC	R13,R3
    00299 F45C      BGE	0x02A5
    0029A 2C2E      MOV	R2,R14
    0029B 2433      CLR	R3
    0029C 0126      MOVW	R4,R12
    0029D 0C42      ADD	R4,R2
    0029E 1C53      ADC	R5,R3
    0029F 2C2A      MOV	R2,R10
    002A0 2433      CLR	R3
    002A1 1442      CP	R4,R2
    002A2 0453      CPC	R5,R3
    002A3 F00C      BLT	0x02A5
    002A4 CF5D      RJMP	0x0202
(0084) 	  }
(0085) 	}
(0086) 	
(0087) 	if(nightFlag)            //夜间模式
    002A5 9020 006C LDS	R2,nightFlag
    002A7 2022      TST	R2
    002A8 F0B1      BEQ	0x02BF
(0088) 	{ 
(0089) 	  Write_Max7219(0x0c, 0x00);
    002A9 2722      CLR	R18
    002AA 2733      CLR	R19
    002AB E00C      LDI	R16,0xC
    002AC E010      LDI	R17,0
    002AD 940E 032D CALL	_Write_Max7219
(0090) 	  main_yellow();
    002AF 940E 034F CALL	_main_yellow
(0091) 	  second_yellow();
    002B1 940E 035B CALL	_second_yellow
(0092) 	  delay_nms(500);
    002B3 EF04      LDI	R16,0xF4
    002B4 E011      LDI	R17,1
    002B5 940E 037B CALL	_delay_nms
(0093) 	  main_close();
    002B7 940E 0352 CALL	_main_close
(0094) 	  second_close();
    002B9 940E 035E CALL	_second_close
(0095) 	  delay_nms(500);
    002BB EF04      LDI	R16,0xF4
    002BC E011      LDI	R17,1
    002BD 940E 037B CALL	_delay_nms
(0096) 	}
(0097) 	
(0098) 	if(urgencyFlag)        //紧急模式
    002BF 9020 006A LDS	R2,urgencyFlag
    002C1 2022      TST	R2
    002C2 F409      BNE	0x02C4
    002C3 C041      RJMP	0x0305
(0099) 	{
(0100) 	  GICR &= ~(1<<INT2);			//关闭外部中断2
    002C4 B78B      IN	R24,0x3B
    002C5 7D8F      ANDI	R24,0xDF
    002C6 BF8B      OUT	0x3B,R24
(0101) 	  main_red();
    002C7 940E 0349 CALL	_main_red
(0102) 	  second_red();
    002C9 940E 0355 CALL	_second_red
    002CB C038      RJMP	0x0304
(0103) 	  while(1)
(0104) 	  {
(0105) 	    if(urgencyFlag==0)break;
    002CC 9020 006A LDS	R2,urgencyFlag
    002CE 2022      TST	R2
    002CF F409      BNE	0x02D1
    002D0 C034      RJMP	0x0305
(0106) 	    LS139_G_H;
    002D1 98DC      CBI	0x1B,4
(0107) 		Write_Max7219(0x0c, 0x00);
    002D2 2722      CLR	R18
    002D3 2733      CLR	R19
    002D4 E00C      LDI	R16,0xC
    002D5 E010      LDI	R17,0
    002D6 940E 032D CALL	_Write_Max7219
(0108) 		delay_nms(500);
    002D8 EF04      LDI	R16,0xF4
    002D9 E011      LDI	R17,1
    002DA 940E 037B CALL	_delay_nms
(0109) 		LS139_G_L;
    002DC 98DC      CBI	0x1B,4
(0110) 		Write_Max7219(0x0c, 0x01);
    002DD E021      LDI	R18,1
    002DE E030      LDI	R19,0
    002DF E00C      LDI	R16,0xC
    002E0 E010      LDI	R17,0
    002E1 940E 032D CALL	_Write_Max7219
(0111) 		Write_Max7219(1,8);
    002E3 E028      LDI	R18,0x8
    002E4 E030      LDI	R19,0
    002E5 E001      LDI	R16,1
    002E6 E010      LDI	R17,0
    002E7 940E 032D CALL	_Write_Max7219
(0112)         Write_Max7219(2,8);
    002E9 E028      LDI	R18,0x8
    002EA E030      LDI	R19,0
    002EB E002      LDI	R16,2
    002EC E010      LDI	R17,0
    002ED 940E 032D CALL	_Write_Max7219
(0113) 		Write_Max7219(3,8);
    002EF E028      LDI	R18,0x8
    002F0 E030      LDI	R19,0
    002F1 E003      LDI	R16,3
    002F2 E010      LDI	R17,0
    002F3 940E 032D CALL	_Write_Max7219
(0114)         Write_Max7219(4,8);
    002F5 E028      LDI	R18,0x8
    002F6 E030      LDI	R19,0
    002F7 E004      LDI	R16,4
    002F8 E010      LDI	R17,0
    002F9 940E 032D CALL	_Write_Max7219
(0115) 		if(urgencyFlag==0)break;
    002FB 9020 006A LDS	R2,urgencyFlag
    002FD 2022      TST	R2
    002FE F409      BNE	0x0300
    002FF C005      RJMP	0x0305
(0116) 		delay_nms(500);
    00300 EF04      LDI	R16,0xF4
    00301 E011      LDI	R17,1
    00302 940E 037B CALL	_delay_nms
    00304 CFC7      RJMP	0x02CC
    00305 CD9B      RJMP	0x00A1
    00306 9621      ADIW	R28,1
    00307 9508      RET
_decode_H:
  data                 --> R10
    00308 92AA      ST	-Y,R10
    00309 2EA0      MOV	R10,R16
(0117) 	  }
(0118) 	}
(0119)   }
(0120)   
(0121)   
(0122) }
(0123) 
(0124) //把秒数十位和个位分拆开
(0125) void decode_H(uchar data)
(0126) {
(0127)   Number_H=data/10;
    0030A E01A      LDI	R17,0xA
    0030B 2D0A      MOV	R16,R10
    0030C 940E 0684 CALL	div8u
    0030E 9300 00A3 STS	Number_H,R16
    00310 90A9      LD	R10,Y+
    00311 9508      RET
_decode_L:
  data                 --> R10
    00312 92AA      ST	-Y,R10
    00313 2EA0      MOV	R10,R16
(0128) }
(0129) void decode_L(uchar data)
(0130) {
(0131)   Number_L=data%10;
    00314 E01A      LDI	R17,0xA
    00315 2D0A      MOV	R16,R10
    00316 940E 0682 CALL	mod8u
    00318 9300 00A2 STS	Number_L,R16
    0031A 90A9      LD	R10,Y+
    0031B 9508      RET
_Write_Max7219_byte:
  i                    --> R20
  DATA                 --> R16
    0031C 934A      ST	-Y,R20
FILE: C:\Users\Administrator\Desktop\交通灯\MAX7219.c
(0001) #include<iom16v.h>
(0002) #include"MAX7219.h"
(0003) #include"delay.h"
(0004) 
(0005) 
(0006) //--------------------------------------------
(0007) //功能：向MAX7219(U3)写入字节
(0008) //入口参数：DATA 
(0009) //出口参数：无
(0010) //说明：
(0011) void Write_Max7219_byte(uchar DATA)         
(0012) {
(0013)     	uchar i;    
(0014) 		Max7219_pinCS_L;		
    0031D 98AF      CBI	0x15,7
(0015) 	    for(i=8;i>=1;i--)
    0031E E048      LDI	R20,0x8
    0031F C009      RJMP	0x0329
(0016)           {		  
(0017)             Max7219_pinCLK_L;
    00320 98AD      CBI	0x15,5
(0018) 			if(DATA&0x80)Max7219_pinDIN_H;
    00321 FF07      SBRS	R16,7
    00322 C002      RJMP	0x0325
    00323 9AAE      SBI	0x15,6
    00324 C001      RJMP	0x0326
(0019) 			else Max7219_pinDIN_L;
    00325 98AE      CBI	0x15,6
(0020)             DATA=DATA<<1;
    00326 0F00      LSL	R16
(0021)             Max7219_pinCLK_H;
    00327 9AAD      SBI	0x15,5
    00328 954A      DEC	R20
    00329 3041      CPI	R20,1
    0032A F7A8      BCC	0x0320
    0032B 9149      LD	R20,Y+
    0032C 9508      RET
_Write_Max7219:
  dat                  --> R10
  address              --> R12
    0032D 92AA      ST	-Y,R10
    0032E 92CA      ST	-Y,R12
    0032F 2EA2      MOV	R10,R18
    00330 2EC0      MOV	R12,R16
(0022)            }                                 
(0023) }
(0024) //-------------------------------------------
(0025) //功能：向MAX7219写入数据
(0026) //入口参数：address、dat
(0027) //出口参数：无
(0028) //说明：
(0029) void Write_Max7219(uchar address,uchar dat)
(0030) { 
(0031)      Max7219_pinCS_L;
    00331 98AF      CBI	0x15,7
(0032) 	 Write_Max7219_byte(address);           //写入地址，即数码管编号
    00332 2D0C      MOV	R16,R12
    00333 DFE8      RCALL	_Write_Max7219_byte
(0033)      Write_Max7219_byte(dat);               //写入数据，即数码管显示数字 
    00334 2D0A      MOV	R16,R10
    00335 DFE6      RCALL	_Write_Max7219_byte
(0034) 	 Max7219_pinCS_H;                        
    00336 9AAF      SBI	0x15,7
    00337 90C9      LD	R12,Y+
    00338 90A9      LD	R10,Y+
    00339 9508      RET
(0035) }
(0036) 
(0037) void Init_MAX7219(void)
(0038) {
(0039)  Write_Max7219(0x09, 0xff);       //译码方式：BCD码
_Init_MAX7219:
    0033A EF2F      LDI	R18,0xFF
    0033B E009      LDI	R16,0x9
    0033C DFF0      RCALL	_Write_Max7219
(0040)  Write_Max7219(0x0a, 0x03);       //亮度
    0033D E023      LDI	R18,3
    0033E E00A      LDI	R16,0xA
    0033F DFED      RCALL	_Write_Max7219
(0041)  Write_Max7219(0x0b, 0x07);       //扫描界限；4个数码管显示
    00340 E027      LDI	R18,7
    00341 E00B      LDI	R16,0xB
    00342 DFEA      RCALL	_Write_Max7219
(0042)  Write_Max7219(0x0c, 0x01);       //掉电模式：0，普通模式：1
    00343 E021      LDI	R18,1
    00344 E00C      LDI	R16,0xC
    00345 DFE7      RCALL	_Write_Max7219
(0043)  Write_Max7219(0x0f, 0x01);       //显示测试：1；测试结束，正常显示：0
    00346 E021      LDI	R18,1
    00347 E00F      LDI	R16,0xF
    00348 CFE4      RJMP	_Write_Max7219
FILE: C:\Users\Administrator\Desktop\交通灯\74LS139.c
(0001) #include<iom16v.h>
(0002) #include"74LS139.h"
(0003) 
(0004) //主干道红灯
(0005) main_red()
(0006) {
(0007)   LS139_1A_L;
_main_red:
    00349 98D8      CBI	0x1B,0
(0008)   LS139_1B_L;
    0034A 98D9      CBI	0x1B,1
    0034B 9508      RET
(0009) }
(0010) 
(0011) //主干道绿灯
(0012) main_green()
(0013) {
(0014)   LS139_1A_H;
_main_green:
    0034C 9AD8      SBI	0x1B,0
(0015)   LS139_1B_L;
    0034D 98D9      CBI	0x1B,1
    0034E 9508      RET
(0016) }
(0017) 
(0018) //主干道黄灯
(0019) main_yellow()
(0020) {
(0021)   LS139_1A_L;
_main_yellow:
    0034F 98D8      CBI	0x1B,0
(0022)   LS139_1B_H;
    00350 9AD9      SBI	0x1B,1
    00351 9508      RET
(0023) }
(0024) 
(0025) //主干道灭灯
(0026) main_close()
(0027) {
(0028)   LS139_1A_H;
_main_close:
    00352 9AD8      SBI	0x1B,0
(0029)   LS139_1B_H;
    00353 9AD9      SBI	0x1B,1
    00354 9508      RET
(0030) }
(0031) 
(0032) //支干道红灯
(0033) second_red()
(0034) {
(0035)   LS139_2A_L;
_second_red:
    00355 98DA      CBI	0x1B,2
(0036)   LS139_2B_L;
    00356 98DB      CBI	0x1B,3
    00357 9508      RET
(0037) }
(0038) 
(0039) //支干道绿灯
(0040) second_green()
(0041) {
(0042)   LS139_2A_H;
_second_green:
    00358 9ADA      SBI	0x1B,2
(0043)   LS139_2B_L;
    00359 98DB      CBI	0x1B,3
    0035A 9508      RET
(0044) }
(0045) 
(0046) //支干道黄灯
(0047) second_yellow()
(0048) {
(0049)   LS139_2A_L;
_second_yellow:
    0035B 98DA      CBI	0x1B,2
(0050)   LS139_2B_H;
    0035C 9ADB      SBI	0x1B,3
    0035D 9508      RET
(0051) }
(0052) 
(0053) //支干道灭灯
(0054) second_close()
(0055) {
(0056)   LS139_2A_H;
_second_close:
    0035E 9ADA      SBI	0x1B,2
(0057)   LS139_2B_H;
    0035F 9ADB      SBI	0x1B,3
    00360 9508      RET
FILE: C:\Users\Administrator\Desktop\交通灯\delay.c
(0001) 
(0002) #include <iom16v.h>
(0003) #include<macros.h>
(0004) 
(0005) void delay_1us(void)                 //1us延时函数
(0006) {
(0007)    NOP();
_delay_1us:
    00361 0000      NOP
    00362 9508      RET
_delay_nus:
  i                    --> R20
  n                    --> R10
    00363 940E 06BC CALL	push_xgset300C
    00365 0158      MOVW	R10,R16
(0008) }
(0009) 
(0010) void delay_nus(unsigned int n)       //N us延时函数
(0011) {
(0012)    unsigned int i=0;
(0013)      for (i=0;i<n;i++)
    00366 2744      CLR	R20
    00367 2755      CLR	R21
    00368 C003      RJMP	0x036C
(0014)          delay_1us();
    00369 DFF7      RCALL	_delay_1us
    0036A 5F4F      SUBI	R20,0xFF
    0036B 4F5F      SBCI	R21,0xFF
    0036C 154A      CP	R20,R10
    0036D 055B      CPC	R21,R11
    0036E F3D0      BCS	0x0369
    0036F 940C 06C1 JMP	pop_xgset300C
(0015) }
(0016)   
(0017) void delay_1ms(void)                 //1ms延时函数
(0018) {
(0019)     unsigned int i;
(0020)     for (i=0;i<1140;i++);
_delay_1ms:
  i                    --> R16
    00371 2700      CLR	R16
    00372 2711      CLR	R17
    00373 C002      RJMP	0x0376
    00374 5F0F      SUBI	R16,0xFF
    00375 4F1F      SBCI	R17,0xFF
    00376 3704      CPI	R16,0x74
    00377 E0E4      LDI	R30,4
    00378 071E      CPC	R17,R30
    00379 F3D0      BCS	0x0374
    0037A 9508      RET
_delay_nms:
  i                    --> R20
  n                    --> R10
    0037B 940E 06BC CALL	push_xgset300C
    0037D 0158      MOVW	R10,R16
(0021) }
(0022)   
(0023) void delay_nms(unsigned int n)       //N ms延时函数
(0024) {
(0025)    unsigned int  i=0;
(0026)    for (i=0;i<n;i++)
    0037E 2744      CLR	R20
    0037F 2755      CLR	R21
    00380 C003      RJMP	0x0384
(0027)    delay_1ms();
    00381 DFEF      RCALL	_delay_1ms
    00382 5F4F      SUBI	R20,0xFF
    00383 4F5F      SBCI	R21,0xFF
    00384 154A      CP	R20,R10
    00385 055B      CPC	R21,R11
    00386 F3D0      BCS	0x0381
    00387 940C 06C1 JMP	pop_xgset300C
FILE: C:\Users\Administrator\Desktop\交通灯\ds1307.c
(0001) 
(0002) #include <iom16v.h>
(0003) #include <macros.h>
(0004) #include"twi.h"
(0005) #include"usart.h"
(0006) 
(0007) uchar time[7]={0};         //读取ds1207内部存储的数据
(0008) uchar secCount=0;
(0009) 
(0010) 
(0011) void int2_init(void)       //配置外部中断2
(0012) {
(0013)     DDRB&=~BIT(2);
_int2_init:
    00389 98BA      CBI	0x17,2
(0014) 	PORTB|=BIT(2);
    0038A 9AC2      SBI	0x18,2
    0038B 9508      RET
_int2:
  time_buf             --> R20
  buf                  --> R10
  i                    --> Y,+2
    0038C 920A      ST	-Y,R0
    0038D 921A      ST	-Y,R1
    0038E 922A      ST	-Y,R2
    0038F 923A      ST	-Y,R3
    00390 924A      ST	-Y,R4
    00391 925A      ST	-Y,R5
    00392 926A      ST	-Y,R6
    00393 927A      ST	-Y,R7
    00394 928A      ST	-Y,R8
    00395 929A      ST	-Y,R9
    00396 930A      ST	-Y,R16
    00397 931A      ST	-Y,R17
    00398 932A      ST	-Y,R18
    00399 933A      ST	-Y,R19
    0039A 938A      ST	-Y,R24
    0039B 939A      ST	-Y,R25
    0039C 93AA      ST	-Y,R26
    0039D 93BA      ST	-Y,R27
    0039E 93EA      ST	-Y,R30
    0039F 93FA      ST	-Y,R31
    003A0 B60F      IN	R0,0x3F
    003A1 920A      ST	-Y,R0
    003A2 92AA      ST	-Y,R10
    003A3 934A      ST	-Y,R20
    003A4 9721      SBIW	R28,1
(0015) }
(0016) 
(0017) #pragma interrupt_handler int2:19          //一次外部中断读取一次ds1307内部存储的数据
(0018) void int2(void)
(0019) {   
(0020)     uchar i;
(0021) 	
(0022) 	GICR &= ~(1<<INT2);			//关闭下降沿触发INT2
    003A5 B78B      IN	R24,0x3B
    003A6 7D8F      ANDI	R24,0xDF
    003A7 BF8B      OUT	0x3B,R24
(0023) 	
(0024) 	secCount++;
    003A8 9180 0068 LDS	R24,secCount
    003AA 5F8F      SUBI	R24,0xFF
    003AB 9380 0068 STS	secCount,R24
(0025) 	if(secCount>=(greenTime+yellowTime+redTime+yellowTime))
    003AD 9040 00A6 LDS	R4,yellowTime
    003AF 9020 00A5 LDS	R2,greenTime
    003B1 0C24      ADD	R2,R4
    003B2 9030 00A4 LDS	R3,redTime
    003B4 0C23      ADD	R2,R3
    003B5 0C24      ADD	R2,R4
    003B6 1582      CP	R24,R2
    003B7 F0F8      BCS	0x03D7
(0026) 	{
(0027) 	    uchar buf=0,time_buf=12;
    003B8 24AA      CLR	R10
    003B9 E04C      LDI	R20,0xC
(0028) 		secCount=0;
    003BA 2422      CLR	R2
    003BB 9220 0068 STS	secCount,R2
(0029) 		
(0030) 		time[2]=TWI_Read(WD_DS1307_ADDR,RD_DS1307_ADDR,2);
    003BD E082      LDI	R24,2
    003BE 8388      ST	Y,R24
    003BF ED21      LDI	R18,0xD1
    003C0 ED00      LDI	R16,0xD0
    003C1 940E 0436 CALL	_TWI_Read
    003C3 9300 0063 STS	time+2,R16
(0031) 		
(0032) 		if(time[2]>=0 && time[2] <= 5)   //凌晨0-5点夜间模式
    003C5 3000      CPI	R16,0
    003C6 F050      BCS	0x03D1
    003C7 E085      LDI	R24,5
    003C8 1780      CP	R24,R16
    003C9 F038      BCS	0x03D1
(0033) 		{
(0034) 		  nightFlag = 1;
    003CA E081      LDI	R24,1
    003CB 9380 006C STS	nightFlag,R24
(0035) 		  daytimeFlag = 0;
    003CD 2422      CLR	R2
    003CE 9220 006B STS	daytimeFlag,R2
(0036) 		}else
    003D0 C006      RJMP	0x03D7
(0037) 		{
(0038) 		  nightFlag = 0;
    003D1 2422      CLR	R2
    003D2 9220 006C STS	nightFlag,R2
(0039) 	      daytimeFlag = 1;
    003D4 E081      LDI	R24,1
    003D5 9380 006B STS	daytimeFlag,R24
(0040) 		}
(0041) 	}
(0042) 	
(0043) 	    
(0044) 	
(0045) 	/*
(0046) 	for(i=0;i<8;i++)                //清空串口暂存数组
(0047) 	{
(0048) 	  getData[i]=0;
(0049) 	}
(0050) 	*/
(0051) 	
(0052) 	GICR |= (1<<INT2);			//下降沿触发INT2
    003D7 B78B      IN	R24,0x3B
    003D8 6280      ORI	R24,0x20
    003D9 BF8B      OUT	0x3B,R24
    003DA 9621      ADIW	R28,1
    003DB 9149      LD	R20,Y+
    003DC 90A9      LD	R10,Y+
    003DD 9009      LD	R0,Y+
    003DE BE0F      OUT	0x3F,R0
    003DF 91F9      LD	R31,Y+
    003E0 91E9      LD	R30,Y+
    003E1 91B9      LD	R27,Y+
    003E2 91A9      LD	R26,Y+
    003E3 9199      LD	R25,Y+
    003E4 9189      LD	R24,Y+
    003E5 9139      LD	R19,Y+
    003E6 9129      LD	R18,Y+
    003E7 9119      LD	R17,Y+
    003E8 9109      LD	R16,Y+
    003E9 9099      LD	R9,Y+
    003EA 9089      LD	R8,Y+
    003EB 9079      LD	R7,Y+
    003EC 9069      LD	R6,Y+
    003ED 9059      LD	R5,Y+
    003EE 9049      LD	R4,Y+
    003EF 9039      LD	R3,Y+
    003F0 9029      LD	R2,Y+
    003F1 9019      LD	R1,Y+
    003F2 9009      LD	R0,Y+
    003F3 9518      RETI
FILE: C:\Users\Administrator\Desktop\交通灯\twi.c
(0001) /********************************************************************
(0002)             利用i2c对外部e2prom进行读写操作
(0003) ********************************************************************/
(0004) #include <iom16v.h>
(0005) #include <macros.h>
(0006) #include"twi.h"
(0007) 
(0008) 
(0009) void TWI_init(void)
(0010) {  
(0011)    TWBR=0X0F;      //比特率
_TWI_init:
    003F4 E08F      LDI	R24,0xF
    003F5 B980      OUT	0x00,R24
(0012)    TWSR=0;         //1分频
    003F6 2422      CLR	R2
    003F7 B821      OUT	0x01,R2
    003F8 9508      RET
_TWI_Write:
  RegAddress           --> R12
  Wdata                --> R10
  SlaveAddress         --> R14
    003F9 940E 06B5 CALL	push_xgset00FC
    003FB 2EA2      MOV	R10,R18
    003FC 2EE0      MOV	R14,R16
    003FD 80CE      LDD	R12,Y+6
(0013) }
(0014) 
(0015) uchar TWI_Write(uchar SlaveAddress,uchar Wdata,uchar RegAddress)
(0016) {
(0017)    Start();      		 	   //TWI启动
    003FE EA84      LDI	R24,0xA4
    003FF BF86      OUT	0x36,R24
(0018)    Wait();
    00400 B626      IN	R2,0x36
    00401 FE27      SBRS	R2,7
    00402 CFFD      RJMP	0x0400
(0019)    if(Satus()!=START) 
    00403 B181      IN	R24,0x01
    00404 7F88      ANDI	R24,0xF8
    00405 3088      CPI	R24,0x8
    00406 F011      BEQ	0x0409
(0020)    return FALSE;    
    00407 E001      LDI	R16,1
    00408 C02B      RJMP	0x0434
(0021)    
(0022)    Write8Bit(SlaveAddress); //写 从机地址和写方式
    00409 B8E3      OUT	0x03,R14
    0040A E884      LDI	R24,0x84
    0040B BF86      OUT	0x36,R24
(0023)    Wait();
    0040C B626      IN	R2,0x36
    0040D FE27      SBRS	R2,7
    0040E CFFD      RJMP	0x040C
(0024)    if(Satus()!=MT_SLA_ACK) 
    0040F B181      IN	R24,0x01
    00410 7F88      ANDI	R24,0xF8
    00411 3188      CPI	R24,0x18
    00412 F011      BEQ	0x0415
(0025)    return FALSE;     
    00413 E001      LDI	R16,1
    00414 C01F      RJMP	0x0434
(0026)       
(0027)    Write8Bit(RegAddress);  	   //写 从机相应寄存器地址
    00415 B8C3      OUT	0x03,R12
    00416 E884      LDI	R24,0x84
    00417 BF86      OUT	0x36,R24
(0028)    Wait();
    00418 B626      IN	R2,0x36
    00419 FE27      SBRS	R2,7
    0041A CFFD      RJMP	0x0418
(0029)    if(Satus()!=MT_DATA_ACK) 
    0041B B181      IN	R24,0x01
    0041C 7F88      ANDI	R24,0xF8
    0041D 3288      CPI	R24,0x28
    0041E F011      BEQ	0x0421
(0030)    return FALSE;        
    0041F E001      LDI	R16,1
    00420 C013      RJMP	0x0434
(0031)   
(0032)    Write8Bit(Wdata);     	   //写数据到 从机相应寄存器
    00421 B8A3      OUT	0x03,R10
    00422 E884      LDI	R24,0x84
    00423 BF86      OUT	0x36,R24
(0033)    Wait();
    00424 B626      IN	R2,0x36
    00425 FE27      SBRS	R2,7
    00426 CFFD      RJMP	0x0424
(0034)    if(Satus()!=MT_DATA_ACK) 
    00427 B181      IN	R24,0x01
    00428 7F88      ANDI	R24,0xF8
    00429 3288      CPI	R24,0x28
    0042A F011      BEQ	0x042D
(0035)    return FALSE;         
    0042B E001      LDI	R16,1
    0042C C007      RJMP	0x0434
(0036)    
(0037)    Stop();        	 		   //TWI停止
    0042D E984      LDI	R24,0x94
    0042E BF86      OUT	0x36,R24
(0038)    delay_nms(10);   		   	   //延时
    0042F E00A      LDI	R16,0xA
    00430 E010      LDI	R17,0
    00431 940E 037B CALL	_delay_nms
(0039)    return TRUE;
    00433 2700      CLR	R16
    00434 940C 06AA JMP	pop_xgset00FC
_TWI_Read:
  temp                 --> R10
  RegAddress           --> R10
  SlaveAddress_R       --> R18
  SlaveAddress_W       --> R16
    00436 92AA      ST	-Y,R10
    00437 80A9      LDD	R10,Y+1
(0040) }
(0041) 
(0042) 
(0043) uchar TWI_Read(uchar SlaveAddress_W,uchar SlaveAddress_R,uchar RegAddress)
(0044) {
(0045)    uchar temp;
(0046)    Start();	   			  	   //TWI启动
    00438 EA84      LDI	R24,0xA4
    00439 BF86      OUT	0x36,R24
(0047)    Wait();
    0043A B626      IN	R2,0x36
    0043B FE27      SBRS	R2,7
    0043C CFFD      RJMP	0x043A
(0048)    //if (Satus()!=START) 
(0049)    // return FALSE;        
(0050)     
(0051)    Write8Bit(SlaveAddress_W); //写 从机地址和写方式
    0043D B903      OUT	0x03,R16
    0043E E884      LDI	R24,0x84
    0043F BF86      OUT	0x36,R24
(0052)    Wait(); 
    00440 B626      IN	R2,0x36
    00441 FE27      SBRS	R2,7
    00442 CFFD      RJMP	0x0440
(0053)    if (Satus()!=MT_SLA_ACK) 
    00443 B181      IN	R24,0x01
    00444 7F88      ANDI	R24,0xF8
    00445 3188      CPI	R24,0x18
    00446 F011      BEQ	0x0449
(0054)     return FALSE;        
    00447 E001      LDI	R16,1
    00448 C032      RJMP	0x047B
(0055)     
(0056)    Write8Bit(RegAddress);      //写 从机相应寄存器地址
    00449 B8A3      OUT	0x03,R10
    0044A E884      LDI	R24,0x84
    0044B BF86      OUT	0x36,R24
(0057)    Wait();
    0044C B626      IN	R2,0x36
    0044D FE27      SBRS	R2,7
    0044E CFFD      RJMP	0x044C
(0058)    if (Satus()!=MT_DATA_ACK) 
    0044F B181      IN	R24,0x01
    00450 7F88      ANDI	R24,0xF8
    00451 3288      CPI	R24,0x28
    00452 F011      BEQ	0x0455
(0059)     return FALSE;
    00453 E001      LDI	R16,1
    00454 C026      RJMP	0x047B
(0060)     
(0061)    Start();            	       //TWI重新启动
    00455 EA84      LDI	R24,0xA4
    00456 BF86      OUT	0x36,R24
(0062)    Wait();
    00457 B626      IN	R2,0x36
    00458 FE27      SBRS	R2,7
    00459 CFFD      RJMP	0x0457
(0063)    if (Satus()!=RE_START)  
    0045A B181      IN	R24,0x01
    0045B 7F88      ANDI	R24,0xF8
    0045C 3180      CPI	R24,0x10
    0045D F011      BEQ	0x0460
(0064)     return FALSE;
    0045E E001      LDI	R16,1
    0045F C01B      RJMP	0x047B
(0065)     
(0066)    Write8Bit(SlaveAddress_R); //写 从机地址和读方式
    00460 B923      OUT	0x03,R18
    00461 E884      LDI	R24,0x84
    00462 BF86      OUT	0x36,R24
(0067)    Wait();
    00463 B626      IN	R2,0x36
    00464 FE27      SBRS	R2,7
    00465 CFFD      RJMP	0x0463
(0068)    if(Satus()!=MR_SLA_ACK)  
    00466 B181      IN	R24,0x01
    00467 7F88      ANDI	R24,0xF8
    00468 3480      CPI	R24,0x40
    00469 F011      BEQ	0x046C
(0069)     return FALSE;      
    0046A E001      LDI	R16,1
    0046B C00F      RJMP	0x047B
(0070)     
(0071)    TWI_READ();          	   //启动主TWI读方式
    0046C E884      LDI	R24,0x84
    0046D BF86      OUT	0x36,R24
(0072)    Wait();
    0046E B626      IN	R2,0x36
    0046F FE27      SBRS	R2,7
    00470 CFFD      RJMP	0x046E
(0073)    if(Satus()!=MR_DATA_NOACK)//读完一个数停止接收数据 ，主机接收到不再接收应答信号 ，如果继续接收到应答信号
    00471 B181      IN	R24,0x01
    00472 7F88      ANDI	R24,0xF8
    00473 3588      CPI	R24,0x58
    00474 F011      BEQ	0x0477
(0074)    							  //说明主机继续接收数据则为错误	 													 																		 
(0075)     return FALSE;     
    00475 E001      LDI	R16,1
    00476 C004      RJMP	0x047B
(0076)     
(0077)    temp=TWDR;        		   //读取 TWI接收数据
    00477 B0A3      IN	R10,0x03
(0078)    Stop();          		   //TWI停止
    00478 E984      LDI	R24,0x94
    00479 BF86      OUT	0x36,R24
(0079)    return temp;
    0047A 2D0A      MOV	R16,R10
    0047B 90A9      LD	R10,Y+
    0047C 9508      RET
_TWI_Read_1307:
  data                 --> Y,+3
  RegAddress           --> R10
  SlaveAddress_R       --> R18
  SlaveAddress_W       --> R16
    0047D 92AA      ST	-Y,R10
    0047E 80A9      LDD	R10,Y+1
(0080) } 
(0081) 
(0082) uchar TWI_Read_1307(uchar SlaveAddress_W,uchar SlaveAddress_R,uchar RegAddress,uchar *data)
(0083) {
(0084)    Start();	   			  	   //TWI启动
    0047F EA84      LDI	R24,0xA4
    00480 BF86      OUT	0x36,R24
(0085)    Wait();
    00481 B626      IN	R2,0x36
    00482 FE27      SBRS	R2,7
    00483 CFFD      RJMP	0x0481
(0086)    if (Satus()!=START) 
    00484 B181      IN	R24,0x01
    00485 7F88      ANDI	R24,0xF8
    00486 3088      CPI	R24,0x8
    00487 F011      BEQ	0x048A
(0087)     return FALSE;        
    00488 E001      LDI	R16,1
    00489 C039      RJMP	0x04C3
(0088)     
(0089)    Write8Bit(SlaveAddress_W); //写 从机地址和写方式
    0048A B903      OUT	0x03,R16
    0048B E884      LDI	R24,0x84
    0048C BF86      OUT	0x36,R24
(0090)    Wait(); 
    0048D B626      IN	R2,0x36
    0048E FE27      SBRS	R2,7
    0048F CFFD      RJMP	0x048D
(0091)    if (Satus()!=MT_SLA_ACK) 
    00490 B181      IN	R24,0x01
    00491 7F88      ANDI	R24,0xF8
    00492 3188      CPI	R24,0x18
    00493 F011      BEQ	0x0496
(0092)     return FALSE;        
    00494 E001      LDI	R16,1
    00495 C02D      RJMP	0x04C3
(0093)     
(0094)    Write8Bit(RegAddress);      //写 从机相应寄存器地址
    00496 B8A3      OUT	0x03,R10
    00497 E884      LDI	R24,0x84
    00498 BF86      OUT	0x36,R24
(0095)    Wait();
    00499 B626      IN	R2,0x36
    0049A FE27      SBRS	R2,7
    0049B CFFD      RJMP	0x0499
(0096)    if (Satus()!=MT_DATA_ACK) 
    0049C B181      IN	R24,0x01
    0049D 7F88      ANDI	R24,0xF8
    0049E 3288      CPI	R24,0x28
    0049F F011      BEQ	0x04A2
(0097)     return FALSE;
    004A0 E001      LDI	R16,1
    004A1 C021      RJMP	0x04C3
(0098)     
(0099)    Start();            	       //TWI重新启动
    004A2 EA84      LDI	R24,0xA4
    004A3 BF86      OUT	0x36,R24
(0100)    Wait();
    004A4 B626      IN	R2,0x36
    004A5 FE27      SBRS	R2,7
    004A6 CFFD      RJMP	0x04A4
(0101)    if (Satus()!=RE_START)  
    004A7 B181      IN	R24,0x01
    004A8 7F88      ANDI	R24,0xF8
    004A9 3180      CPI	R24,0x10
    004AA F011      BEQ	0x04AD
(0102)     return FALSE;
    004AB E001      LDI	R16,1
    004AC C016      RJMP	0x04C3
(0103)     
(0104)    Write8Bit(SlaveAddress_R); //写 从机地址和读方式
    004AD B923      OUT	0x03,R18
    004AE E884      LDI	R24,0x84
    004AF BF86      OUT	0x36,R24
(0105)    Wait();
    004B0 B626      IN	R2,0x36
    004B1 FE27      SBRS	R2,7
    004B2 CFFD      RJMP	0x04B0
(0106)    if(Satus()!=MR_SLA_ACK)  
    004B3 B181      IN	R24,0x01
    004B4 7F88      ANDI	R24,0xF8
    004B5 3480      CPI	R24,0x40
    004B6 F011      BEQ	0x04B9
(0107)     return FALSE;      
    004B7 E001      LDI	R16,1
    004B8 C00A      RJMP	0x04C3
(0108)     
(0109)    TWI_READ();          	   //启动主TWI读方式
    004B9 E884      LDI	R24,0x84
    004BA BF86      OUT	0x36,R24
(0110)    Wait();
    004BB B626      IN	R2,0x36
    004BC FE27      SBRS	R2,7
    004BD CFFD      RJMP	0x04BB
(0111)    if(Satus()!=MR_DATA_NOACK)//读完一个数停止接收数据 ，主机接收到不再接收应答信号 ，如果继续接收到应答信号						  
    004BE B181      IN	R24,0x01
    004BF 7F88      ANDI	R24,0xF8
    004C0 3588      CPI	R24,0x58
    004C1 F009      BEQ	0x04C3
(0112)                              //说明主机继续接收数据则为错误	 													 																		 
(0113)     return FALSE;     
    004C2 E001      LDI	R16,1
    004C3 90A9      LD	R10,Y+
    004C4 9508      RET
_Twi_write_data:
  i                    --> R20
    004C5 934A      ST	-Y,R20
    004C6 935A      ST	-Y,R21
    004C7 9721      SBIW	R28,1
(0114)     
(0115)    /*temp=TWDR;        		   //读取 TWI接收数据
(0116)    Stop();          		   //TWI停止
(0117)    return temp;*/
(0118) } 
(0119) 
(0120) 
(0121) void Twi_write_data(void)
(0122) {
(0123)    uint i;
(0124)    for(i=0;i<4;i++)
    004C8 2744      CLR	R20
    004C9 2755      CLR	R21
    004CA C008      RJMP	0x04D3
(0125)    {
(0126)       TWI_Write(WD_AT2402C_ADDR,'0'+i,i);     //写入0-3
    004CB 8348      ST	Y,R20
    004CC 019A      MOVW	R18,R20
    004CD 5D20      SUBI	R18,0xD0
    004CE 4F3F      SBCI	R19,0xFF
    004CF EA00      LDI	R16,0xA0
    004D0 DF28      RCALL	_TWI_Write
    004D1 5F4F      SUBI	R20,0xFF
    004D2 4F5F      SBCI	R21,0xFF
    004D3 3044      CPI	R20,4
    004D4 E0E0      LDI	R30,0
    004D5 075E      CPC	R21,R30
    004D6 F3A0      BCS	0x04CB
(0127)    }
(0128)    
(0129)    for(i=0;i<26;i++)
    004D7 2744      CLR	R20
    004D8 2755      CLR	R21
    004D9 C00A      RJMP	0x04E4
(0130)    {
(0131)       TWI_Write(WD_AT2402C_ADDR,'A'+i,(4+i)); //写入大写字母表
    004DA 01CA      MOVW	R24,R20
    004DB 9604      ADIW	R24,4
    004DC 8388      ST	Y,R24
    004DD 019A      MOVW	R18,R20
    004DE 5B2F      SUBI	R18,0xBF
    004DF 4F3F      SBCI	R19,0xFF
    004E0 EA00      LDI	R16,0xA0
    004E1 DF17      RCALL	_TWI_Write
    004E2 5F4F      SUBI	R20,0xFF
    004E3 4F5F      SBCI	R21,0xFF
    004E4 314A      CPI	R20,0x1A
    004E5 E0E0      LDI	R30,0
    004E6 075E      CPC	R21,R30
    004E7 F390      BCS	0x04DA
(0132)    }
(0133)    
(0134)    for(i=0;i<26;i++)
    004E8 2744      CLR	R20
    004E9 2755      CLR	R21
    004EA C00A      RJMP	0x04F5
(0135)    {
(0136)       TWI_Write(WD_AT2402C_ADDR,'a'+i,(30+i));//写入小写字母表
    004EB 01CA      MOVW	R24,R20
    004EC 964E      ADIW	R24,0x1E
    004ED 8388      ST	Y,R24
    004EE 019A      MOVW	R18,R20
    004EF 592F      SUBI	R18,0x9F
    004F0 4F3F      SBCI	R19,0xFF
    004F1 EA00      LDI	R16,0xA0
    004F2 DF06      RCALL	_TWI_Write
    004F3 5F4F      SUBI	R20,0xFF
    004F4 4F5F      SBCI	R21,0xFF
    004F5 314A      CPI	R20,0x1A
    004F6 E0E0      LDI	R30,0
    004F7 075E      CPC	R21,R30
    004F8 F390      BCS	0x04EB
(0137)    }
(0138)    
(0139)    for(i=56;i<=255;i++)
    004F9 E348      LDI	R20,0x38
    004FA E050      LDI	R21,0
    004FB C006      RJMP	0x0502
(0140)    {
(0141)       TWI_Write(WD_AT2402C_ADDR,'0',i);       //其他写入0
    004FC 8348      ST	Y,R20
    004FD E320      LDI	R18,0x30
    004FE EA00      LDI	R16,0xA0
    004FF DEF9      RCALL	_TWI_Write
    00500 5F4F      SUBI	R20,0xFF
    00501 4F5F      SBCI	R21,0xFF
    00502 EF8F      LDI	R24,0xFF
    00503 E090      LDI	R25,0
    00504 1784      CP	R24,R20
    00505 0795      CPC	R25,R21
    00506 F7A8      BCC	0x04FC
    00507 9621      ADIW	R28,1
    00508 9159      LD	R21,Y+
    00509 9149      LD	R20,Y+
    0050A 9508      RET
FILE: C:\Users\Administrator\Desktop\交通灯\usart.c
(0001) /******************************************
(0002)     利用中断接收串口接收数据，再对数据进行
(0003) 	分类判断和执行命令，然后对字母输出
(0004) ******************************************/
(0005) 
(0006) 
(0007) #include<iom16v.h>
(0008) #include<macros.h>
(0009) #include<string.h>
(0010) #include"usart.h"
(0011) #include"twi.h"
(0012) 
(0013) uchar k=0;
(0014) uchar getData[20];   //接收数组
(0015) 
(0016) uchar urgencyFlag=0,daytimeFlag=1,nightFlag=0;  //事件状态标志位
(0017) uchar yellowTime,greenTime,redTime;
(0018) 
(0019) 
(0020) void usart_init(void)     //配置usart寄存器
(0021) {
(0022)      DDRD&=~(1<<PD0);PORTD|=1<<PD0;
_usart_init:
    0050B 9888      CBI	0x11,0
    0050C 9A90      SBI	0x12,0
(0023) 	 DDRD|=1<<PD1;PORTD|=1<<PD1;
    0050D 9A89      SBI	0x11,1
    0050E 9A91      SBI	0x12,1
(0024) 	 UCSRC = (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);        //8位字符长度
    0050F E886      LDI	R24,0x86
    00510 BD80      OUT	0x20,R24
(0025) 	 UBRRL = 51;                                          //9600bps   8M
    00511 E383      LDI	R24,0x33
    00512 B989      OUT	0x09,R24
(0026) 	 UCSRB = (1<<RXCIE) | (1<<RXEN) | (1<<TXEN);          //接收中断，发送中断，接收使能，发送使能                                     
    00513 E988      LDI	R24,0x98
    00514 B98A      OUT	0x0A,R24
    00515 9508      RET
_usart_read:
  buf                  --> Y,+3
  time_buf             --> R10
  dataBuf              --> R10
  dataBuf              --> R10
  dataBuf              --> R10
    00516 920A      ST	-Y,R0
    00517 921A      ST	-Y,R1
    00518 922A      ST	-Y,R2
    00519 923A      ST	-Y,R3
    0051A 924A      ST	-Y,R4
    0051B 925A      ST	-Y,R5
    0051C 926A      ST	-Y,R6
    0051D 927A      ST	-Y,R7
    0051E 928A      ST	-Y,R8
    0051F 929A      ST	-Y,R9
    00520 930A      ST	-Y,R16
    00521 931A      ST	-Y,R17
    00522 932A      ST	-Y,R18
    00523 933A      ST	-Y,R19
    00524 938A      ST	-Y,R24
    00525 939A      ST	-Y,R25
    00526 93AA      ST	-Y,R26
    00527 93BA      ST	-Y,R27
    00528 93EA      ST	-Y,R30
    00529 93FA      ST	-Y,R31
    0052A B60F      IN	R0,0x3F
    0052B 920A      ST	-Y,R0
    0052C 940E 06BC CALL	push_xgset300C
    0052E 9722      SBIW	R28,2
(0027) } 
(0028) 
(0029) #pragma interrupt_handler usart_read:12
(0030) void usart_read(void)                   
(0031) {       
(0032)      while ( !(UCSRA & (1<<RXC)) );     // 等待接收缓存器空
    0052F 9B5F      SBIS	0x0B,7
    00530 CFFE      RJMP	0x052F
(0033)      getData[k]=UDR;
    00531 EA87      LDI	R24,0xA7
    00532 E090      LDI	R25,0
    00533 91E0 0069 LDS	R30,k
    00535 27FF      CLR	R31
    00536 0FE8      ADD	R30,R24
    00537 1FF9      ADC	R31,R25
    00538 B02C      IN	R2,0x0C
    00539 8220      ST	Z,R2
(0034)      k++;
    0053A 9180 0069 LDS	R24,k
    0053C 5F8F      SUBI	R24,0xFF
    0053D 9380 0069 STS	k,R24
(0035) 	 if((strncmp("green",getData,5))==0)   //修改主干道绿灯时间
    0053F E085      LDI	R24,5
    00540 E090      LDI	R25,0
    00541 8399      STD	Y+1,R25
    00542 8388      ST	Y,R24
    00543 EA27      LDI	R18,0xA7
    00544 E030      LDI	R19,0
    00545 E90C      LDI	R16,0x9C
    00546 E010      LDI	R17,0
    00547 940E 066E CALL	_strncmp
    00549 3000      CPI	R16,0
    0054A 0701      CPC	R16,R17
    0054B F509      BNE	0x056D
(0036) 	 { 
(0037) 	    uchar dataBuf;          
(0038) 		dataBuf = (usart_get()-0x30)*10;
    0054C D0F0      RCALL	_usart_get
    0054D E08A      LDI	R24,0xA
    0054E E090      LDI	R25,0
    0054F 0198      MOVW	R18,R16
    00550 018C      MOVW	R16,R24
    00551 940E 069A CALL	empy16s
    00553 01C8      MOVW	R24,R16
    00554 5E80      SUBI	R24,0xE0
    00555 4091      SBCI	R25,1
    00556 2EA8      MOV	R10,R24
(0039) 		dataBuf = dataBuf + (usart_get()-0x30);
    00557 D0E5      RCALL	_usart_get
    00558 01A8      MOVW	R20,R16
    00559 01CA      MOVW	R24,R20
    0055A 97C0      SBIW	R24,0x30
    0055B 2C2A      MOV	R2,R10
    0055C 2433      CLR	R3
    0055D 0E28      ADD	R2,R24
    0055E 1E39      ADC	R3,R25
    0055F 2CA2      MOV	R10,R2
(0040) 		greenTime = dataBuf;
    00560 92A0 00A5 STS	greenTime,R10
(0041) 		Write_EEprom(greenTime,1);
    00562 E021      LDI	R18,1
    00563 E030      LDI	R19,0
    00564 2D02      MOV	R16,R2
    00565 2711      CLR	R17
    00566 940E 065A CALL	_Write_EEprom
(0042) 		usart_send('1');
    00568 E301      LDI	R16,0x31
    00569 D0CD      RCALL	_usart_send
(0043)         k=0;
    0056A 2422      CLR	R2
    0056B 9220 0069 STS	k,R2
(0044) 	 }
(0045) 	 if((strncmp("red",getData,3))==0)   //修改支干道红灯时间
    0056D E083      LDI	R24,3
    0056E E090      LDI	R25,0
    0056F 8399      STD	Y+1,R25
    00570 8388      ST	Y,R24
    00571 EA27      LDI	R18,0xA7
    00572 E030      LDI	R19,0
    00573 E908      LDI	R16,0x98
    00574 E010      LDI	R17,0
    00575 940E 066E CALL	_strncmp
    00577 0158      MOVW	R10,R16
    00578 3000      CPI	R16,0
    00579 0701      CPC	R16,R17
    0057A F4F9      BNE	0x059A
(0046) 	 { 
(0047) 	    uchar dataBuf;          
(0048) 		dataBuf = (usart_get()-0x30)*10;
    0057B D0C1      RCALL	_usart_get
    0057C 0158      MOVW	R10,R16
    0057D E00A      LDI	R16,0xA
    0057E E010      LDI	R17,0
    0057F 0195      MOVW	R18,R10
    00580 940E 069A CALL	empy16s
    00582 01C8      MOVW	R24,R16
    00583 5E80      SUBI	R24,0xE0
    00584 4091      SBCI	R25,1
    00585 2EA8      MOV	R10,R24
(0049) 		dataBuf = dataBuf + (usart_get()-0x30);
    00586 D0B6      RCALL	_usart_get
    00587 01A8      MOVW	R20,R16
    00588 01CA      MOVW	R24,R20
    00589 97C0      SBIW	R24,0x30
    0058A 2C2A      MOV	R2,R10
    0058B 2433      CLR	R3
    0058C 0E28      ADD	R2,R24
    0058D 1E39      ADC	R3,R25
    0058E 2CA2      MOV	R10,R2
(0050) 		redTime = dataBuf;
    0058F 92A0 00A4 STS	redTime,R10
(0051)         Write_EEprom(redTime,0);
    00591 2722      CLR	R18
    00592 2733      CLR	R19
    00593 2D02      MOV	R16,R2
    00594 2711      CLR	R17
    00595 940E 065A CALL	_Write_EEprom
(0052)         k=0;
    00597 2422      CLR	R2
    00598 9220 0069 STS	k,R2
(0053) 	 }
(0054) 	 if((strncmp("yellow",getData,6))==0)   //修改黄灯时间 
    0059A E086      LDI	R24,6
    0059B E090      LDI	R25,0
    0059C 8399      STD	Y+1,R25
    0059D 8388      ST	Y,R24
    0059E EA27      LDI	R18,0xA7
    0059F E030      LDI	R19,0
    005A0 E901      LDI	R16,0x91
    005A1 E010      LDI	R17,0
    005A2 940E 066E CALL	_strncmp
    005A4 0158      MOVW	R10,R16
    005A5 3000      CPI	R16,0
    005A6 0701      CPC	R16,R17
    005A7 F4F9      BNE	0x05C7
(0055) 	 { 
(0056) 	    uchar dataBuf;          
(0057) 		dataBuf = (usart_get()-0x30)*10;
    005A8 D094      RCALL	_usart_get
    005A9 0158      MOVW	R10,R16
    005AA E00A      LDI	R16,0xA
    005AB E010      LDI	R17,0
    005AC 0195      MOVW	R18,R10
    005AD 940E 069A CALL	empy16s
    005AF 01C8      MOVW	R24,R16
    005B0 5E80      SUBI	R24,0xE0
    005B1 4091      SBCI	R25,1
    005B2 2EA8      MOV	R10,R24
(0058) 		dataBuf = dataBuf + (usart_get()-0x30);
    005B3 D089      RCALL	_usart_get
    005B4 01A8      MOVW	R20,R16
    005B5 01CA      MOVW	R24,R20
    005B6 97C0      SBIW	R24,0x30
    005B7 2C2A      MOV	R2,R10
    005B8 2433      CLR	R3
    005B9 0E28      ADD	R2,R24
    005BA 1E39      ADC	R3,R25
    005BB 2CA2      MOV	R10,R2
(0059) 		yellowTime = dataBuf;
    005BC 92A0 00A6 STS	yellowTime,R10
(0060) 		Write_EEprom(yellowTime,2);
    005BE E022      LDI	R18,2
    005BF E030      LDI	R19,0
    005C0 2D02      MOV	R16,R2
    005C1 2711      CLR	R17
    005C2 940E 065A CALL	_Write_EEprom
(0061)         k=0;
    005C4 2422      CLR	R2
    005C5 9220 0069 STS	k,R2
(0062) 	 }
(0063) 	 if((strncmp("urgencystart",getData,12))==0)   //紧急情况发生
    005C7 E08C      LDI	R24,0xC
    005C8 E090      LDI	R25,0
    005C9 8399      STD	Y+1,R25
    005CA 8388      ST	Y,R24
    005CB EA27      LDI	R18,0xA7
    005CC E030      LDI	R19,0
    005CD E804      LDI	R16,0x84
    005CE E010      LDI	R17,0
    005CF 940E 066E CALL	_strncmp
    005D1 0158      MOVW	R10,R16
    005D2 3000      CPI	R16,0
    005D3 0701      CPC	R16,R17
    005D4 F441      BNE	0x05DD
(0064) 	 { 
(0065) 	    urgencyFlag = 1;
    005D5 E081      LDI	R24,1
    005D6 9380 006A STS	urgencyFlag,R24
(0066) 		daytimeFlag = 0;
    005D8 2422      CLR	R2
    005D9 9220 006B STS	daytimeFlag,R2
(0067) 		nightFlag = 0;
    005DB 9220 006C STS	nightFlag,R2
(0068) 	 }
(0069) 	 if((strncmp("urgencystop",getData,11))==0)   //紧急情况停止
    005DD E08B      LDI	R24,0xB
    005DE E090      LDI	R25,0
    005DF 8399      STD	Y+1,R25
    005E0 8388      ST	Y,R24
    005E1 EA27      LDI	R18,0xA7
    005E2 E030      LDI	R19,0
    005E3 E708      LDI	R16,0x78
    005E4 E010      LDI	R17,0
    005E5 940E 066E CALL	_strncmp
    005E7 0158      MOVW	R10,R16
    005E8 3000      CPI	R16,0
    005E9 0701      CPC	R16,R17
    005EA F441      BNE	0x05F3
(0070) 	 { 
(0071) 	    urgencyFlag = 0;
    005EB 2422      CLR	R2
    005EC 9220 006A STS	urgencyFlag,R2
(0072) 		daytimeFlag = 1;
    005EE E081      LDI	R24,1
    005EF 9380 006B STS	daytimeFlag,R24
(0073) 		nightFlag = 0;
    005F1 9220 006C STS	nightFlag,R2
(0074) 	 }
(0075) 	 if((strncmp("timechange",getData,10))==0)   //紧急情况停止
    005F3 E08A      LDI	R24,0xA
    005F4 E090      LDI	R25,0
    005F5 8399      STD	Y+1,R25
    005F6 8388      ST	Y,R24
    005F7 EA27      LDI	R18,0xA7
    005F8 E030      LDI	R19,0
    005F9 E60D      LDI	R16,0x6D
    005FA E010      LDI	R17,0
    005FB 940E 066E CALL	_strncmp
    005FD 0158      MOVW	R10,R16
    005FE 3000      CPI	R16,0
    005FF 0701      CPC	R16,R17
    00600 F4E1      BNE	0x061D
(0076) 	 { 
(0077) 	    uchar buf,time_buf;
(0078) 		
(0079) 		time_buf = (usart_get()-0x30)*10;
    00601 D03B      RCALL	_usart_get
    00602 0158      MOVW	R10,R16
    00603 E00A      LDI	R16,0xA
    00604 E010      LDI	R17,0
    00605 0195      MOVW	R18,R10
    00606 940E 069A CALL	empy16s
    00608 01C8      MOVW	R24,R16
    00609 5E80      SUBI	R24,0xE0
    0060A 4091      SBCI	R25,1
    0060B 2EA8      MOV	R10,R24
(0080) 		time_buf = time_buf + (usart_get()-0x30);
    0060C D030      RCALL	_usart_get
    0060D 01A8      MOVW	R20,R16
    0060E 01CA      MOVW	R24,R20
    0060F 97C0      SBIW	R24,0x30
    00610 2C2A      MOV	R2,R10
    00611 2433      CLR	R3
    00612 0E28      ADD	R2,R24
    00613 1E39      ADC	R3,R25
    00614 2CA2      MOV	R10,R2
(0081) 		TWI_Write(WD_DS1307_ADDR,time_buf,2);
    00615 E082      LDI	R24,2
    00616 8388      ST	Y,R24
    00617 2D22      MOV	R18,R2
    00618 ED00      LDI	R16,0xD0
    00619 940E 03F9 CALL	_TWI_Write
(0082) 		
(0083) 		usart_send(time_buf);
    0061B 2D0A      MOV	R16,R10
    0061C D01A      RCALL	_usart_send
(0084) 	 }
    0061D 9622      ADIW	R28,2
    0061E 940E 06C1 CALL	pop_xgset300C
    00620 9009      LD	R0,Y+
    00621 BE0F      OUT	0x3F,R0
    00622 91F9      LD	R31,Y+
    00623 91E9      LD	R30,Y+
    00624 91B9      LD	R27,Y+
    00625 91A9      LD	R26,Y+
    00626 9199      LD	R25,Y+
    00627 9189      LD	R24,Y+
    00628 9139      LD	R19,Y+
    00629 9129      LD	R18,Y+
    0062A 9119      LD	R17,Y+
    0062B 9109      LD	R16,Y+
    0062C 9099      LD	R9,Y+
    0062D 9089      LD	R8,Y+
    0062E 9079      LD	R7,Y+
    0062F 9069      LD	R6,Y+
    00630 9059      LD	R5,Y+
    00631 9049      LD	R4,Y+
    00632 9039      LD	R3,Y+
    00633 9029      LD	R2,Y+
    00634 9019      LD	R1,Y+
    00635 9009      LD	R0,Y+
    00636 9518      RETI
(0085) 
(0086) }
(0087) 
(0088) void usart_send(uchar data)             //TXD发送数据
(0089) {
(0090)      
(0091)     while(!(UCSRA & (1<<UDRE)));   //等待发送缓存器空
_usart_send:
  data                 --> R16
    00637 9B5D      SBIS	0x0B,5
    00638 CFFE      RJMP	_usart_send
(0092)     UDR = data;
    00639 B90C      OUT	0x0C,R16
(0093)     while(!(UCSRA & (1<<TXC)));    //等待发送结束
    0063A 9B5E      SBIS	0x0B,6
    0063B CFFE      RJMP	0x063A
    0063C 9508      RET
(0094) }
(0095) 
(0096) uchar usart_get()             //RXD接收数据
(0097) {
(0098)     
(0099)     while ( !(UCSRA & (1<<RXC)) );     // 等待接收缓存器空
_usart_get:
    0063D 9B5F      SBIS	0x0B,7
    0063E CFFE      RJMP	_usart_get
(0100) 	return UDR;
    0063F B10C      IN	R16,0x0C
    00640 9508      RET
_Read_EEprom:
  j                    --> R10
  address              --> R20
    00641 940E 06BC CALL	push_xgset300C
    00643 01A8      MOVW	R20,R16
FILE: C:\Users\Administrator\Desktop\交通灯\eeprom.c
(0001) /********************************************************************
(0002)             对ATMEGA16内部e2prom进行读写操作
(0003) ********************************************************************/
(0004) #include <iom16v.h>
(0005) #include<macros.h>
(0006) #include"eeprom.h"
(0007) #include"delay.h"
(0008) 	  
(0009) 
(0010) /******************************************************************************/
(0011) //读内部EEPROM函数
(0012) /******************************************************************************/  				 
(0013) uchar Read_EEprom(uint address)
(0014) {
(0015)     uchar j;
(0016) 	if(EECR&0x01)delay_nms(32);
    00644 9BE0      SBIS	0x1C,0
    00645 C004      RJMP	0x064A
    00646 E200      LDI	R16,0x20
    00647 E010      LDI	R17,0
    00648 940E 037B CALL	_delay_nms
(0017) 	EEARH=address&0x0100;
    0064A 01CA      MOVW	R24,R20
    0064B 7080      ANDI	R24,0
    0064C 7091      ANDI	R25,1
    0064D BB8F      OUT	0x1F,R24
(0018) 	EEARL=address&0x00ff;
    0064E 01CA      MOVW	R24,R20
    0064F 7090      ANDI	R25,0
    00650 BB8E      OUT	0x1E,R24
(0019) 	EECR|=0x01;       //EEPROM 读使能
    00651 9AE0      SBI	0x1C,0
(0020) 	delay_nms(32);
    00652 E200      LDI	R16,0x20
    00653 E010      LDI	R17,0
    00654 940E 037B CALL	_delay_nms
(0021) 	j=EEDR;      //读取数据
    00656 B2AD      IN	R10,0x1D
(0022) 	return(j);
    00657 2D0A      MOV	R16,R10
    00658 940C 06C1 JMP	pop_xgset300C
_Write_EEprom:
  address              --> R20
  data                 --> R10
    0065A 940E 06BC CALL	push_xgset300C
    0065C 01A9      MOVW	R20,R18
    0065D 2EA0      MOV	R10,R16
(0023) }
(0024) /******************************************************************************/
(0025) //写入EEPORM函数
(0026) /******************************************************************************/  				  
(0027) void Write_EEprom(uchar data,uint address)
(0028) {
(0029) 	EEARH=address&0x0100;
    0065E 01CA      MOVW	R24,R20
    0065F 7080      ANDI	R24,0
    00660 7091      ANDI	R25,1
    00661 BB8F      OUT	0x1F,R24
(0030) 	EEARL=address&0x00ff; 
    00662 01CA      MOVW	R24,R20
    00663 7090      ANDI	R25,0
    00664 BB8E      OUT	0x1E,R24
(0031) 	EEDR=data;    //写入数据
    00665 BAAD      OUT	0x1D,R10
(0032) 	EECR|=0x04;   //EEPROM 主机写使能
    00666 9AE2      SBI	0x1C,2
(0033)     EECR|=0x02;   //EEPROM 写使能
    00667 9AE1      SBI	0x1C,1
(0034) 	delay_nms(32);
FILE: <library>
    00668 E200      LDI	R16,0x20
    00669 E010      LDI	R17,0
    0066A 940E 037B CALL	_delay_nms
    0066C 940C 06C1 JMP	pop_xgset300C
_strncmp:
    0066E 8188      LD	R24,Y
    0066F 8199      LDD	R25,Y+1
    00670 3080      CPI	R24,0
    00671 0798      CPC	R25,R24
    00672 F061      BEQ	0x067F
    00673 2FF1      MOV	R31,R17
    00674 2FE0      MOV	R30,R16
    00675 2FB3      MOV	R27,R19
    00676 2FA2      MOV	R26,R18
    00677 9101      LD	R16,Z+
    00678 911D      LD	R17,X+
    00679 1B01      SUB	R16,R17
    0067A F429      BNE	0x0680
    0067B 2311      TST	R17
    0067C F011      BEQ	0x067F
    0067D 9701      SBIW	R24,1
    0067E F7C1      BNE	0x0677
    0067F 2700      CLR	R16
    00680 0B11      SBC	R17,R17
    00681 9508      RET
mod8u:
    00682 9468      BSET	6
    00683 C001      RJMP	xdiv8u
div8u:
    00684 94E8      BCLR	6
xdiv8u:
    00685 932A      ST	-Y,R18
    00686 92FA      ST	-Y,R15
    00687 92EA      ST	-Y,R14
    00688 24FF      CLR	R15
    00689 24EE      CLR	R14
    0068A E120      LDI	R18,0x10
    0068B 0F00      LSL	R16
    0068C 1CFF      ROL	R15
    0068D 1CEE      ROL	R14
    0068E 16E1      CP	R14,R17
    0068F F010      BCS	0x0692
    00690 1AE1      SUB	R14,R17
    00691 9503      INC	R16
    00692 952A      DEC	R18
    00693 F7B9      BNE	0x068B
    00694 F40E      BRTC	0x0696
    00695 2D0E      MOV	R16,R14
    00696 90E9      LD	R14,Y+
    00697 90F9      LD	R15,Y+
    00698 9129      LD	R18,Y+
    00699 9508      RET
empy16s:
    0069A 920A      ST	-Y,R0
    0069B 921A      ST	-Y,R1
    0069C 938A      ST	-Y,R24
    0069D 939A      ST	-Y,R25
    0069E 9F02      MUL	R16,R18
    0069F 01C0      MOVW	R24,R0
    006A0 9F12      MUL	R17,R18
    006A1 0D90      ADD	R25,R0
    006A2 9F03      MUL	R16,R19
    006A3 0D90      ADD	R25,R0
    006A4 018C      MOVW	R16,R24
    006A5 9199      LD	R25,Y+
    006A6 9189      LD	R24,Y+
    006A7 9019      LD	R1,Y+
    006A8 9009      LD	R0,Y+
    006A9 9508      RET
pop_xgset00FC:
    006AA 90A9      LD	R10,Y+
    006AB 90B9      LD	R11,Y+
    006AC 90C9      LD	R12,Y+
    006AD 90D9      LD	R13,Y+
    006AE 90E9      LD	R14,Y+
    006AF 90F9      LD	R15,Y+
    006B0 9508      RET
push_xgsetF0FC:
    006B1 937A      ST	-Y,R23
    006B2 936A      ST	-Y,R22
push_xgset30FC:
    006B3 935A      ST	-Y,R21
    006B4 934A      ST	-Y,R20
push_xgset00FC:
    006B5 92FA      ST	-Y,R15
    006B6 92EA      ST	-Y,R14
push_xgset003C:
    006B7 92DA      ST	-Y,R13
    006B8 92CA      ST	-Y,R12
    006B9 92BA      ST	-Y,R11
    006BA 92AA      ST	-Y,R10
    006BB 9508      RET
push_xgset300C:
    006BC 935A      ST	-Y,R21
    006BD 934A      ST	-Y,R20
    006BE 92BA      ST	-Y,R11
    006BF 92AA      ST	-Y,R10
    006C0 9508      RET
pop_xgset300C:
    006C1 90A9      LD	R10,Y+
    006C2 90B9      LD	R11,Y+
    006C3 9149      LD	R20,Y+
    006C4 9159      LD	R21,Y+
    006C5 9508      RET
